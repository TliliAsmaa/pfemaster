import 'dart:io';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:google_mlkit_text_recognition/google_mlkit_text_recognition.dart';
import 'package:http/http.dart' as http;
import 'analyse_resultat.dart';
import 'resultats_page.dart';
import 'prediction_data.dart';
import 'dart:convert';
class ImagePredictionPage extends StatefulWidget {
  const ImagePredictionPage({super.key});

  @override
  State<ImagePredictionPage> createState() => _ImagePredictionPageState();
}

class _ImagePredictionPageState extends State<ImagePredictionPage> {
  File? _image;
  bool _isLoading = false;


  Future<void> _pickImageFromGallery() async {
    final pickedFile = await ImagePicker().pickImage(source: ImageSource.gallery);
    if (pickedFile != null) {
      setState(() {
        _image = File(pickedFile.path);
      });
    }
  }

  Future<void> _pickImageFromCamera() async {
    final pickedFile = await ImagePicker().pickImage(source: ImageSource.camera);
    if (pickedFile != null) {
      setState(() {
        _image = File(pickedFile.path);
      });
    }
  }


  /*Future<void> _performOCR() async {
  if (_image == null) return;

setState(() {
    _isLoading = true;
  });
  final inputImage = InputImage.fromFile(_image!);
  final textRecognizer = TextRecognizer(script: TextRecognitionScript.latin);

  final RecognizedText recognizedText = await textRecognizer.processImage(inputImage);

  String extractedText = recognizedText.text;

   setState(() {
    _isLoading = false;
  });
  // Pour le moment, on affiche dans une alerte simple
  showDialog(
    context: context,
    builder: (_) => AlertDialog(
      title: Text("Texte extrait"),
      content: SingleChildScrollView(child: Text(extractedText)),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: Text("Fermer"),
        )
      ],
    ),
  );
}*/
/*Future<void> _sendImageToBackend(File imageFile) async {
  var uri = Uri.parse('http://192.168.7.247:5000/extract');
  var request = http.MultipartRequest('POST', uri);

  request.files.add(await http.MultipartFile.fromPath('image', imageFile.path));

  var response = await request.send();

  if (response.statusCode == 200) {
    final responseBody = await response.stream.bytesToString();
    print("‚úÖ R√©sultat du backend : $responseBody");

    // Tu peux afficher le r√©sultat dans l'UI ici
  } else {
    print("‚ùå Erreur backend : ${response.statusCode}");
  }
}*/

 Future<void> _analyserImage(File imageFile) async {
    if (_image == null) return;
    setState(() {
      _isLoading = true;
    });

    final uri = Uri.parse('http:// 192.168.1.39:5000/analyse');
    var request =
        http.MultipartRequest('POST', uri)
          ..fields['gender'] = 'homme'
          ..fields['age'] = '30'
          ..files.add(await http.MultipartFile.fromPath('image', _image!.path));

    var response = await request.send();

    if (response.statusCode == 200) {
      final responseBody = await response.stream.bytesToString();
      try {
        final jsonMap = json.decode(responseBody);

        if (jsonMap['results'] != null && jsonMap['results'] is List) {
          final results = jsonMap['results'] as List;
          List<AnalyseResult> analyses =
              results.map((r) => AnalyseResult.fromJson(r)).toList();
          PredictionData? predictionData;
          if (jsonMap['data'] != null) {
            predictionData = PredictionData.fromJson(jsonMap['data']);
          }
          if (mounted) {
            Navigator.push(
              context,
              MaterialPageRoute(
                builder:
                    (context) => ResultatsPage(
                      resultats: analyses,
                      resultats2:
                          predictionData != null ? [predictionData] : [],
                    ),
              ),
            );
          }
        } else {
          _showError("Format inattendu : pas de cl√© 'results'.");
        }
      } catch (e) {
        _showError("Erreur de d√©codage JSON : $e");
      }
    } else {
      _showError("Erreur lors de l'analyse");
    }

    setState(() {
      _isLoading = false;
    });
  }

  void _showError(String message) {
    showDialog(
      context: context,
      builder:
          (_) => AlertDialog(
            title: const Text("Erreur"),
            content: Text(message),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text("OK"),
              ),
            ],
          ),
    );
  }


  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor:  Color(0xFFF7FBFF),
      appBar: AppBar(
       // title: Text("Pr√©diction via Image"),
       backgroundColor: Color(0xFFF7FBFF),
      ),
      body:
      Container(
        child:ListView(
          children:[
            Center(
        
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: Column(
            
            children: [

              const SizedBox(height: 20),
              const Text(
                "Bienvenue dans votre assistant de sant√© !",
                textAlign: TextAlign.center,
                style: TextStyle(
                       
                        fontSize: 27,
                        fontWeight: FontWeight.w400,
                        color:Color(0xFF4A90E2),
                        height: 1.8,
                        letterSpacing:1.5
                      ),
              ),
              SizedBox(height:20),
              const Text(
                "Veuillez importer une image claire et lisible de votre test m√©dical, et laissez notre syst√®me intelligent vous fournir une analyse rapide et fiable.",
                textAlign: TextAlign.center,
                style: TextStyle(fontSize: 16,
                        fontWeight: FontWeight.w500,
                        color:Colors.black,
                        height: 1.5,
                        letterSpacing:1.5
                      ),
                
                
              ),
              const SizedBox(height: 40),
              Container(
                
                padding: const EdgeInsets.all(20),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(20),
                  boxShadow: [BoxShadow(color: Colors.black12, blurRadius: 10)],
                ),
                child: Column(
                  children: [
                    Icon(Icons.cloud_upload, size: 50, color: Colors.blue),
                    const SizedBox(height: 16),
                    const Text(
                      "Importer une image",
                      style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 8),
                   
                    const SizedBox(height: 20),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        ElevatedButton.icon(
                          onPressed: _pickImageFromGallery,
                          icon: Icon(Icons.folder, color:Colors.white),
                          label: Text("Parcourir",style:TextStyle(color:Colors.white)),
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.blue,
                          ),
                        ),
                        const SizedBox(width: 10),
                        OutlinedButton.icon(
                          onPressed: _pickImageFromCamera,
                          icon: Icon(Icons.camera_alt),
                          label: Text("Utiliser la cam√©ra"),
                          style: OutlinedButton.styleFrom(
                            foregroundColor: Colors.blue,
                            side: BorderSide(color: Colors.blue),
                          ),
                        ),
                      ],
                    )
                  ],
                ),
              ),
              const SizedBox(height: 30),
              if (_image != null)
                Column(
                  children: [
                    Text("Image s√©lectionn√©e :"),
                    const SizedBox(height: 10),
                    Image.file(_image!, height: 200),

                     // üëâ Tu ajoutes le bouton ici :
                     const SizedBox(height: 20),
                     _isLoading
        ? CircularProgressIndicator()
        : ElevatedButton(
           onPressed: () async {
  if (_image != null) {
    await _analyserImage(_image! );
  }
},

            child: Text("Analyser l'image"),
          ),
                  ],
                ),
            ],
          ),
        ),
      ),
          ],
        ),
      ),
       
    );
  }
}





/*====================================code binome ====================================*/

/*import 'dart:io';
//import 'package:permission_handler/permission_handler.dart';
import 'package:flutter/material.dart';

import 'package:google_mlkit_text_recognition/google_mlkit_text_recognition.dart';
import 'package:image_picker/image_picker.dart';

import 'package:image/image.dart' as img;
import 'package:google_ml_kit/google_ml_kit.dart';
import 'dart:convert';
import 'package:flutter/services.dart' show rootBundle;
import 'package:http/http.dart' as http;





class MedicalResult {
  final String name;
  final String value;
  final String unit;
  final String category;

  MedicalResult({
    required this.name,
    required this.value,
    required this.unit,
    required this.category,
  });
}
/*Future<void> requestPermissions() async {
  await [
    Permission.camera,
    Permission.photos,
    Permission.storage,
  ].request();
}*/
class ImagePredictionPage extends StatefulWidget {
  const ImagePredictionPage({super.key});

  @override
  State<ImagePredictionPage> createState() => _ImagePredictionPageState();
}

class _ImagePredictionPageState extends State<ImagePredictionPage> {
  bool textScanning = false;
  XFile? imageFile;
  List<MedicalResult> results = [];
  List<String> unrecognizedLines = [];
  String fullExtractedText = "";

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Analyse M√©dicale OCR")),
      body: Center(
        child: SingleChildScrollView(
          child: Container(
            margin: const EdgeInsets.all(20),
            child: Column(
              children: [
                if (textScanning) const CircularProgressIndicator(),
                if (!textScanning && imageFile == null)
                  Container(width: 300, height: 300, color: Colors.grey[300]),
                if (imageFile != null) Image.file(File(imageFile!.path)),
                const SizedBox(height: 20),
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    _imageButton("Galerie", Icons.image, ImageSource.gallery),
                    const SizedBox(width: 10),
                    _imageButton(
                      "Cam√©ra",
                      Icons.camera_alt,
                      ImageSource.camera,
                    ),
                  ],
                ),
                const SizedBox(height: 20),
                if (results.isNotEmpty)
                  ...groupByCategory(results).entries.map(
                    (entry) => buildResultsSection(entry.key, entry.value),
                  ),
                if (results.isNotEmpty || fullExtractedText.isNotEmpty) 
                  ElevatedButton.icon(
                    onPressed: () async {
                      final datasetTests = await loadDatasetTests();
                      final ocrTests = results.map((e) => e.name).toList();

                      try {
                        final analysis = await analyzeWithGemini(
                          ocrAnalyses: ocrTests,
                          datasetAnalyses: datasetTests,
                          results: results,
                          fullExtractedText: fullExtractedText,
                        );

                        // Sauvegarder dans Firebase
                        //await saveFinalResultsToFirebase(analysis);
                        showDialog(
                          context: context,
                          
                          builder:
                         
                              (_) => AlertDialog(
                                 
                                title: const Text('Analyse OpenAI'),
                                content: SingleChildScrollView(
                                  child: SelectableText(
                                    const JsonEncoder.withIndent(
                                      '  ',
                                    ).convert(analysis),
                                    style: const TextStyle(fontSize: 14),
                                  ),
                                ),
                                actions: [
                                  TextButton(
                                    child: const Text('Fermer'),
                                    onPressed: () => Navigator.pop(context),
                                  ),
                                ],
                              ),
                        );
                        
                      } catch (e) {
                        showDialog(
                          context: context,
                          builder:
                              (_) => AlertDialog(
                                title: const Text('Erreur OpenAI'),
                                content: Text(e.toString()),
                              ),
                        );
                      }
                    },
                    icon: const Icon(Icons.smart_toy),
                    label: const Text("Analyser avec OpenAI"),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.deepPurple,
                      foregroundColor: Colors.white,
                    ),
                  ),
                if (unrecognizedLines.isNotEmpty) buildUnrecognizedSection(),
                if (fullExtractedText.isNotEmpty) buildFullTextSection(),
                
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _imageButton(String label, IconData icon, ImageSource source) {
    return ElevatedButton(
      style: ElevatedButton.styleFrom(
        backgroundColor: Colors.white,
        foregroundColor: Colors.grey,
        elevation: 10,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8.0)),
      ),
      onPressed: () async{//await requestPermissions();  
       await getImage(source);},
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 30),
          Text(label, style: TextStyle(fontSize: 13, color: Colors.grey[600])),
        ],
      ),
    );
  }

  Future<void> preprocessImage(XFile image) async {
    final file = File(image.path);
    final img.Image? originalImage = img.decodeImage(file.readAsBytesSync());

    if (originalImage != null) {
      // 1Ô∏è‚É£ Conversion en niveaux de gris
      img.Image grayImage = img.grayscale(originalImage);

      // 2Ô∏è‚É£ Augmentation du contraste
      grayImage = img.adjustColor(
        grayImage,
        contrast: 150,
      ); // 100 = normal, >100 augmente

      // 3Ô∏è‚É£ Binarisation (noir et blanc)
      for (int y = 0; y < grayImage.height; y++) {
        for (int x = 0; x < grayImage.width; x++) {
          final pixel = grayImage.getPixel(x, y);
          final luma = img.getLuminanceRgb(
            pixel.r.toInt(),
            pixel.g.toInt(),
            pixel.b.toInt(),
          );
          final color =
              (luma < 128)
                  ? img.ColorRgb8(0, 0, 0)
                  : img.ColorRgb8(255, 255, 255);
          grayImage.setPixel(x, y, color);
        }
      }

      // 4Ô∏è‚É£ (Optionnel) Lissage pour r√©duire le bruit
      // grayImage = img.gaussianBlur(grayImage, 1);

      // 5Ô∏è‚É£ Redimensionnement pour standardiser la taille
      final processedImage = img.copyResize(grayImage, width: 800);

      // Sauvegarder l‚Äôimage pr√©trait√©e temporairement
      final preprocessedFile = File(
        '${file.parent.path}/preprocessed_image.jpg',
      );
      preprocessedFile.writeAsBytesSync(img.encodeJpg(processedImage));

      // Petite pause pour √™tre s√ªr que le fichier est bien √©crit avant OCR
      await Future.delayed(const Duration(milliseconds: 500));

      // Lancer l'extraction OCR sur l‚Äôimage pr√©trait√©e
      await extractMedicalData(XFile(preprocessedFile.path));
    }
  }

  Future<void> getImage(ImageSource source) async {
    try {
      final pickedImage = await ImagePicker().pickImage(source: source);
      if (pickedImage != null) {
        setState(() {
          textScanning = true;
          imageFile = pickedImage;
          results.clear();
          unrecognizedLines.clear();
          fullExtractedText = "";
        });
        await preprocessImage(pickedImage);
      }
    } catch (e) {
      setState(() {
        textScanning = false;
        imageFile = null;
        results.clear();
        unrecognizedLines.clear();
        fullExtractedText = "";
      });
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Erreur lors de l\'extraction : $e')),
      );
    }
  }
  /*
  Future<Map<String, dynamic>?> getUserSexAndAge() async {
    try {
      final uid = FirebaseAuth.instance.currentUser!.uid;

      final userDoc =
          await FirebaseFirestore.instance.collection('users').doc(uid).get();

      if (userDoc.exists) {
        final data = userDoc.data();
        if (data != null) {
          final String? gender = data['gender']; // "Male" ou "Female"
          final String? birthDateString =
              data['birth date']; // Format: "2023-04-27"

          if (gender != null && birthDateString != null) {
            final birthdate = DateTime.parse(birthDateString);
            final today = DateTime.now();
            int age = today.year - birthdate.year;
            if (today.month < birthdate.month ||
                (today.month == birthdate.month && today.day < birthdate.day)) {
              age--; // Corriger si l'anniversaire n'est pas encore pass√© cette ann√©e
            }

            // Convertir gender en entier
            int sexValue = (gender.toLowerCase() == 'male') ? 1 : 0;

            return {'sex': sexValue, 'age': age};
          }
        }
      }
      return null;
    } catch (e) {
      print('Erreur lors de la r√©cup√©ration de sex et age : $e');
      return null;
    }
  }*/

 /* Future<List<String>> loadMedicalTests() async {
    final String response = await rootBundle.loadString(
      'assets/medical_tests.json',
    );
    final data = json.decode(response);
    return List<String>.from(data['tests']);
  }*/

  Future<void> extractMedicalData(XFile image) async {
    setState(() {
      textScanning = true;
    });

    final inputImage = InputImage.fromFilePath(image.path);
    final textRecognizer = TextRecognizer(script: TextRecognitionScript.latin);
    final RecognizedText recognizedText = await textRecognizer.processImage(
      inputImage,
    );
    
    await textRecognizer.close();

    fullExtractedText = "";

    for (TextBlock block in recognizedText.blocks) {
      for (TextLine line in block.lines) {
        String raw = line.text.trim();
        if (raw.isNotEmpty) {
          fullExtractedText += "$raw\n";
        }
      }
    }

    setState(() {
      textScanning = false;
    });
  }

  /*
  Future<void> extractMedicalData(XFile image) async {
    setState(() {
      textScanning = true;
    });

    final inputImage = InputImage.fromFilePath(image.path);
    final textRecognizer = GoogleMlKit.vision.textRecognizer();
    final RecognizedText recognizedText = await textRecognizer.processImage(
      inputImage,
    );
    await textRecognizer.close();

    fullExtractedText = "";
    results.clear();
    unrecognizedLines.clear();

    List<String> names = [];
    List<String> values = [];

    List<String> knownMedicalTests = await loadMedicalTests();

    // D√©tection intelligente du test m√©dical le plus proche
    String? findClosestMedicalTest(String input) {
      var result = input.bestMatch(knownMedicalTests);
      if (result.bestMatch.rating != null && result.bestMatch.rating! > 0.75) {
        return result.bestMatch.target;
      }
      return null;
    }

    final RegExp valueRegex = RegExp(
      r'^-?\d+([.,]?\d+)?',
      caseSensitive: false,
    );

    final RegExp ignoreRegex = RegExp(
      r'(patient|nom|date|m√©decin|laboratoire|num√©ro|pr√©nom|age|sexe)',
      caseSensitive: false,
    );

    List<String> allLines = [];

    for (TextBlock block in recognizedText.blocks) {
      for (TextLine line in block.lines) {
        String raw = line.text.trim();
        if (raw.isEmpty || ignoreRegex.hasMatch(raw)) continue;
        allLines.add(raw);
        fullExtractedText += "$raw\n";
      }
    }

    for (String line in allLines) {
      String lower = line.toLowerCase();

      final detectedName = findClosestMedicalTest(lower);
      if (detectedName != null) {
        names.add(detectedName);
      } else if (valueRegex.hasMatch(line)) {
        final match = valueRegex.firstMatch(line);
        if (match != null) {
          String val = match.group(0)!.replaceAll(",", ".");
          values.add(val);
        }
      } else {
        unrecognizedLines.add(line);
      }
    }
    int count = [names.length, values.length].reduce((a, b) => a < b ? a : b);

    for (int i = 0; i < count; i++) {
      results.add(
        MedicalResult(
          name: names[i],
          value: values[i],
          unit: "", // Vide car on √©limine les unit√©s
          category: classifyCategory(names[i]),
        ),
      );
    }

    setState(() {
      textScanning = false;
    });
  }
*/
  Future<List<String>> loadDatasetTests() async {
    final csvData = await rootBundle.loadString(
      'images/heart_failure_clinical_records_dataset.csv',
    );
    final lines = const LineSplitter().convert(csvData);
    final headers = lines.first.split(',');
    return headers;
  }

  Future<Map<String, dynamic>> analyzeWithGemini({
    required List<String> ocrAnalyses,
    required List<String> datasetAnalyses,
    required List<MedicalResult> results,
    required String fullExtractedText,
  }) async {
    const apiKey = 'AIzaSyAAFm6SGgZpniwCJ-_LWSZtElaYeLxLjHU';
    final url = Uri.parse(
      'https://generativelanguage.googleapis.com/v1/models/gemini-1.5-pro:generateContent?key=$apiKey',
    );

    final resultsText = fullExtractedText;

    // üî• Ajout : R√©cup√©ration de l'√¢ge et du sexe utilisateur
    /* Map<String, dynamic>? userInfo;
    try {
      userInfo = await getUserSexAndAge();
      if (userInfo == null) {
        throw Exception('Informations utilisateur introuvables.');
      }
    } catch (e) {
      throw Exception(
        'Impossible de r√©cup√©rer l\'√¢ge et le sexe de l\'utilisateur : $e',
      );
    }*/

    final int sex = 1;
    final int age = 65;

    // üî• Modification : Int√©gration dans le prompt
    final prompt = """
Tu es un assistant m√©dical expert.

Je te fournis un texte brut OCR contenant des r√©sultats d‚Äôanalyses m√©dicales. Ce texte peut inclure :
- des noms d‚Äôanalyses (ex. : H√©moglobine, Cr√©atinine, etc.),
- des valeurs (ex. : 11.5 g/dL, 1.2 mg/dL),
- mais aussi des donn√©es non pertinentes (noms du laboratoire, informations administratives, d√©tails du patient, etc.).

Le format est le suivant :
- Une liste de noms d‚Äôanalyses (chaque nom sur une ligne).
- Ensuite, une liste de valeurs (dans le m√™me ordre que les noms).
- D'autres textes divers peuvent √™tre pr√©sents n'importe o√π.

Voici le texte brut :
$resultsText


Informations suppl√©mentaires :
- Le sexe du patient est d√©j√† connu : - Sexe: ${sex == 1 ? 'Homme' : 'Femme'}
- L'√¢ge du patient est d√©j√† connu : - √Çge: $age ans.
Ta mission :

1. Ignore tout le texte qui n‚Äôest pas une analyse m√©dicale (exemple : nom du labo, informations patient, date, etc.).
2. Associe chaque nom d‚Äôanalyse √† sa valeur correspondante m√™me si le format est perturb√©.
3. Analyse uniquement les r√©sultats pertinents pour remplir les colonnes suivantes (comme dans un fichier CSV m√©dical) :

["age", "anaemia", "creatinine_phosphokinase", "diabetes", "ejection_fraction", "high_blood_pressure", "platelets", "serum_creatinine", "serum_sodium", "sex", "smoking", "time"]

R√®gles de remplissage :

1. **H√©matologie (NFS - Num√©ration Formule Sanguine)** :
   - Si l'h√©moglobine est inf√©rieure √† 12 g/dL, alors **anaemia** = 1, sinon 0.
   - **platelets** : Si la num√©ration plaquettaire est pr√©sente, utilise la valeur pour ce champ (assure-toi que c'est en (kiloplatelets/mL) , convertie vers cette unit√© si necessaire).

2. **Biochimie Sanguine** :
   - **serum_creatinine** : Utilise le niveau de cr√©atinine pour remplir ce champ (assure-toi que c'est en (mg/dL)).
   - **diabetes** : Si le glucose √† jeun est sup√©rieur √† 1.26 g/L, alors **diabetes** = 1.
   - **serum_sodium** : Remplis ce champ avec la valeur du sodium dans le sang (assure-toi que c'est en (mEq/L)).

3. **Bilan Cardiaque** :
   - **creatinine_phosphokinase** : Si la CPK (cr√©atine phosphokinase) est pr√©sente, utilise cette valeur pour le champ **creatinine_phosphokinase** (assure-toi que c'est en (mcg/L))

4. **Bilan R√©nal** :
   - **serum_creatinine** : Si la cr√©atinine est pr√©sente, utilise cette valeur pour le champ **serum_creatinine** (assure-toi que c'est en (mg/dL)).
   - **creatinine_phosphokinase** : Si la cr√©atinine phosphokinase est mentionn√©e, renseigne-la dans le champ **creatinine_phosphokinase** (assure-toi que c'est en (mcg/L)).


6. **Bilan H√©patique** :
   - **ASAT/ALAT** : Si ces tests sont pr√©sents, renseigne les r√©sultats pour l'AST et ALT.
   - **Gamma-GT** : Si pr√©sent, renseigne ce test pour le bilan h√©patique.

7. **Lipides** :
   - **Cholest√©rol** : Si le cholest√©rol total ou HDL/LDL est mentionn√©, renseigne-les dans les champs correspondants.

8. **Autres r√®gles g√©n√©rales** :
   - **ejection_fraction** : Si la fraction d'√©jection est pr√©sente, utilise cette valeur pour le champ (assure-toi que c'est en %).
   - **high_blood_pressure** : Si la pression art√©rielle est sup√©rieure √† 140/90 mmHg, alors **high_blood_pressure** =1,sinon =0.
   - **smoking** : Si des informations sur le tabagisme sont pr√©sentes, utilise-les pour remplir le champ (1 pour fumeur, 0 pour non fumeur).
   - **time** et souvent inconnu, donc mets `0` 

**Tr√®s important** :  
Si une colonne reste vide (`null`) apr√®s avoir appliqu√© les r√®gles ci-dessus, **propose une valeur probable** en te basant sur :
- Les autres r√©sultats extraits.
- Les tendances g√©n√©rales du dataset m√©dical habituel.


Si malgr√© cela la valeur est impossible √† estimer, laisse `null`.
Retourne uniquement un objet JSON avec les cl√©s demand√©es, sans balises Markdown.
""";

    try {
      final response = await http.post(
        url,
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'contents': [
            {
              'parts': [
                {'text': prompt},
              ],
            },
          ],
        }),
      );

      if (response.statusCode != 200) {
        throw Exception(
          "Erreur Gemini (${response.statusCode}) : ${response.body}",
        );
      }
       print("R√©ponse de Gemini : ${response.body}");
        

/*if (rawText != null && rawText.contains("pas assez d'informations pour faire une pr√©diction")) {
  print("==========================less info============================");
  return {"error": "pas assez d'informations"};
  throw Exception("Pas assez d'informations pour faire une pr√©diction.");
}*/
        throw Exception("R√©ponse vide de Gemini");
     
      final data = jsonDecode(response.body);
     final rawText = data['candidates']?[0]?['content']?['parts']?[0]?['text'];

      if (rawText == null) {
        throw Exception("R√©ponse vide ou inattendue : ${response.body}");
      }

      // Nettoyage des balises Markdown
      final cleanedText =
          rawText
              .replaceAll(RegExp(r'^```json'), '')
              .replaceAll('```', '')
              .trim();

      try {
        final parsed = jsonDecode(cleanedText);
        if (parsed is Map<String, dynamic>) return parsed;
        throw Exception("R√©ponse JSON invalide : $cleanedText");
      } catch (e) {
        throw Exception(
          "Erreur de parsing JSON : $e\nR√©ponse brute : $cleanedText",
        );
      }
    } catch (e) {
      throw Exception("Erreur dans analyzeWithGemini : $e");
    }
  }

  String classifyCategory(String name) {
    final biochimieKeywords = [
      "glyc",
      "chol",
      "ur√©e",
      "cr√©at",
      "phosph",
      "calc√©",
      "glucose",
      "transamin",
      "ASAT",
      "ALAT",
    ];
    final hematoKeywords = [
      "globule",
      "h√©mato",
      "plaquette",
      "leuco",
      "VGM",
      "CCMH",
      "RDW",
    ];
    name = name.toLowerCase();
    if (biochimieKeywords.any((kw) => name.contains(kw))) {
      return "Biochimie";
    } else if (hematoKeywords.any((kw) => name.contains(kw))) {
      return "H√©matologie";
    } else {
      return "Autre";
    }
  }

  Map<String, List<MedicalResult>> groupByCategory(
    List<MedicalResult> results,
  ) {
    Map<String, List<MedicalResult>> map = {};
    for (var result in results) {
      map.putIfAbsent(result.category, () => []).add(result);
    }
    return map;
  }

  Widget buildResultsSection(
    String sectionTitle,
    List<MedicalResult> sectionResults,
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const SizedBox(height: 10),
        Text(
          sectionTitle,
          style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 8),
        ...sectionResults.map(
          (res) => Card(
            elevation: 4,
            margin: const EdgeInsets.symmetric(vertical: 5),
            child: ListTile(
              title: Text(
                res.name,
                style: const TextStyle(fontWeight: FontWeight.bold),
              ),
              subtitle: Text(
                "Valeur : ${res.value} ${res.unit} (${res.category})",
                style: TextStyle(color: Colors.grey[700]),
              ),
            ),
          ),
        ),
      ],
    );
  }

  Widget buildUnrecognizedSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const SizedBox(height: 10),
        const Text(
          "Lignes non reconnues",
          style: TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
            color: Colors.red,
          ),
        ),
        const SizedBox(height: 8),
        ...unrecognizedLines.map(
          (line) => Card(
            color: Colors.red[50],
            child: Padding(
              padding: const EdgeInsets.all(8.0),
              child: Text(line, style: TextStyle(color: Colors.red[900])),
            ),
          ),
        ),
      ],
    );
  }

  Widget buildFullTextSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const SizedBox(height: 10),
        const Text(
          "Texte brut extrait",
          style: TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
            color: Colors.blue,
          ),
        ),
        const SizedBox(height: 8),
        Container(
          width: double.infinity,
          padding: const EdgeInsets.all(10),
          decoration: BoxDecoration(
            color: Colors.blue[50],
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: Colors.blue.shade100),
          ),
          child: Text(fullExtractedText, style: const TextStyle(fontSize: 14)),
        ),
      ],
    );
  }
}
*/